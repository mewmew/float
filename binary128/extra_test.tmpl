// Code generated by go run gen.go; DO NOT EDIT.

package binary128

import (
	"math"
	"math/big"
	"testing"
)

func TestNewFromBitsNormalized(t *testing.T) {
	testNewFromBits(t, goldenNormalized)
}

func TestNewFromBitsDenormalized(t *testing.T) {
	testNewFromBits(t, goldenDenormalized)
}

func testNewFromBits(t *testing.T, golden []Golden) {
	for _, g := range golden {
		f := NewFromBits(g.a, g.b)
		// Check arbitrary precision floating-point value.
		got, _ := f.Big()
		gotStr := got.Text('g', 35)
		if g.want != gotStr {
			t.Errorf("0x%016X%016X: floating-point number mismatch; expected %v, got %v", g.a, g.b, g.want, gotStr)
		}
		// Check 64-bit floating-point value.
		got64, acc64 := f.Float64()
		want64Bits := math.Float64bits(g.want64)
		got64Bits := math.Float64bits(got64)
		if want64Bits != got64Bits {
			t.Errorf("0x%016X%016X: floating-point number mismatch; expected 0x%016X (%v), got 0x%016X (%v)", g.a, g.b, want64Bits, g.want64, got64Bits, got64)
		}
		// Check accuracy of 64-bit floating-point value, as compared to arbitrary
		// precision floating-point value.
		if g.acc64 != acc64 {
			t.Errorf("0x%016X%016X: floating-point accuracy mismatch for float64 %v of big %v; expected %v, got %v", g.a, g.b, g.want64, g.want, g.acc64, acc64)
		}
		// Validate 64-bit floating-point accuracy.
		wantBig, _ := big.NewFloat(0).SetPrec(precision).SetString(g.want)
		got64Big := big.NewFloat(got64)
		switch acc64 {
		case big.Below:
			// got is below want
			if got64Big.Cmp(wantBig) != -1 {
				t.Errorf("%v: floating-point value not below; expected %v < %v, got %v >= %v", g.want, got64, g.want, got64, g.want)
			}
		case big.Exact:
			// got is want
			if got64Big.Cmp(wantBig) != 0 {
				t.Errorf("%v: floating-point value not equal; expected %v == %v, got %v != %v", g.want, got64, g.want, got64, g.want)
			}
		case big.Above:
			// got is above want
			if got64Big.Cmp(wantBig) != 1 {
				t.Errorf("%v: floating-point value not above; expected %v > %v, got %v <= %v", g.want, got64, g.want, got64, g.want)
			}
		}
		// Validate 32-bit floating-point accuracy.
		got32, acc32 := f.Float32()
		got32Big := big.NewFloat(float64(got32))
		switch acc32 {
		case big.Below:
			// got is below want
			if got32Big.Cmp(wantBig) != -1 {
				t.Errorf("%v: floating-point value not below; expected %v < %v, got %v >= %v", g.want, got32, g.want, got32, g.want)
			}
		case big.Exact:
			// got is want
			if got32Big.Cmp(wantBig) != 0 {
				t.Errorf("%v: floating-point value not equal; expected %v == %v, got %v != %v", g.want, got32, g.want, got32, g.want)
			}
		case big.Above:
			// got is above want
			if got32Big.Cmp(wantBig) != 1 {
				t.Errorf("%v: floating-point value not above; expected %v > %v, got %v <= %v", g.want, got32, g.want, got32, g.want)
			}
		}
	}
}

func TestNewFromFloat32Normalized(t *testing.T) {
	for _, g := range goldenNormalized {
		want32 := float32(g.want64)
		f, _ := NewFromFloat32(want32)
		got32, _ := f.Float32()
		if want32 != got32 {
			t.Errorf("%v: floating-point value mismatch; expected %v, got %v", g.want, want32, got32)
		}
	}
}

func TestNewFromFloat64Normalized(t *testing.T) {
	for _, g := range goldenNormalized {
		f, _ := NewFromFloat64(g.want64)
		got64, _ := f.Float64()
		if g.want64 != got64 {
			t.Errorf("%v: floating-point value mismatch; expected %v, got %v", g.want, g.want64, got64)
		}
	}
}

func TestNewFromFloat32Denormalized(t *testing.T) {
	for _, g := range goldenDenormalized {
		want32 := float32(g.want64)
		f, _ := NewFromFloat32(want32)
		got32, _ := f.Float32()
		if want32 != got32 {
			t.Errorf("%v: floating-point value mismatch; expected %v, got %v", g.want, want32, got32)
		}
	}
}

func TestNewFromFloat64Denormalized(t *testing.T) {
	for _, g := range goldenDenormalized {
		f, _ := NewFromFloat64(g.want64)
		got64, _ := f.Float64()
		if g.want64 != got64 {
			t.Errorf("%v: floating-point value mismatch; expected %v, got %v", g.want, g.want64, got64)
		}
	}
}

type Golden struct {
	a, b   uint64
	want   string
	want64 float64
	acc64  big.Accuracy
}

var goldenNormalized = []Golden{
	// Normalized values.
	{{- range .normalized }}
	{{ . }}
	{{- end }}
}

var goldenDenormalized = []Golden{
	// Denormalized values.
	{{- range .denormalized }}
	{{ . }}
	{{- end }}
}
