//+build ignore

package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"math"
	"math/big"
	"os"
)

func main() {
	var out string
	flag.StringVar(&out, "o", "extra_test.go", "test cases output path")
	flag.Parse()
	if err := dumpTest(out); err != nil {
		log.Fatalf("%+v", err)
	}
}

func dumpTest(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	const pre = `
// Code generated by go run gen.go; DO NOT EDIT.

package binary16

import (
	"math"
	"testing"
)

func TestNewFromBitsNormalized(t *testing.T) {
	for _, g := range goldenNormalized {
		f := NewFromBits(g.bits)
		got, _ := f.Float64()
		wantBits := math.Float64bits(g.want)
		gotBits := math.Float64bits(got)
		if wantBits != gotBits {
			t.Errorf("0x%04X: number mismatch; expected 0x%016X (%v), got 0x%016X (%v)", g.bits, wantBits, g.want, gotBits, got)
		}
	}
}

func TestNewFromBitsDenormalized(t *testing.T) {
	for _, g := range goldenDenormalized {
		f := NewFromBits(g.bits)
		got, _ := f.Float64()
		wantBits := math.Float64bits(g.want)
		gotBits := math.Float64bits(got)
		if wantBits != gotBits {
			t.Errorf("0x%04X: number mismatch; expected 0x%016X (%v), got 0x%016X (%v)", g.bits, wantBits, g.want, gotBits, got)
		}
	}
}


func TestNewFromFloat32Normalized(t *testing.T) {
	for _, g := range goldenNormalized {
		in := float32(g.want)
		f, acc := NewFromFloat32(in)
		_ = acc
		got := f.Bits()
		if g.bits != got {
			t.Errorf("%v: bits mismatch; expected 0x%04X, got 0x%04X", in, g.bits, got)
		}
	}
}

func TestNewFromFloat64Normalized(t *testing.T) {
	for _, g := range goldenNormalized {
		f, acc := NewFromFloat64(g.want)
		_ = acc
		got := f.Bits()
		if g.bits != got {
			t.Errorf("%v: bits mismatch; expected 0x%04X, got 0x%04X", g.want, g.bits, got)
		}
	}
}

func TestNewFromFloat32Denormalized(t *testing.T) {
	for _, g := range goldenDenormalized {
		f, acc := NewFromFloat32(float32(g.want))
		_ = acc
		got := f.Bits()
		if g.bits != got {
			t.Errorf("%v: bits mismatch; expected 0x%04X, got 0x%04X", g.want, g.bits, got)
		}
	}
}

func TestNewFromFloat64Denormalized(t *testing.T) {
	for _, g := range goldenDenormalized {
		f, acc := NewFromFloat64(g.want)
		_ = acc
		got := f.Bits()
		if g.bits != got {
			t.Errorf("%v: bits mismatch; expected 0x%04X, got 0x%04X", g.want, g.bits, got)
		}
	}
}
`
	fmt.Fprintln(f, pre[1:])
	printNormalized(f)
	fmt.Fprintln(f)
	printDenormalized(f)

	return nil
}

const bias = 15

func printNormalized(w io.Writer) {
	const pre = `
var goldenNormalized = []struct {
	bits uint16
	want float64
}{
	// Normalized values.`
	fmt.Fprintln(w, pre[1:])
	// normalized
	// 0b00001 - 0b11110
	//
	//    (-1)^signbit * 2^(exp-15) * 1.mant_2
	const lead = 1
	for signbit := 0; signbit <= 1; signbit++ {
		for exp := 1; exp <= 0x1E; exp++ {
			// 0b1111111111
			for mant := 0; mant <= 0x3FF; mant++ {
				s := fmt.Sprintf("%s0b%d.%010bp0", "+", lead, mant)
				m, _, err := big.ParseFloat(s, 0, 53, big.ToNearestEven)
				if err != nil {
					panic(err)
				}
				mantissa, acc := m.Float64()
				if acc != big.Exact {
					panic("not exact")
				}
				x := math.Pow(-1, float64(signbit)) * math.Pow(2, float64(exp)-bias) * mantissa
				bits := uint16(signbit) << 15
				bits |= uint16(exp) << 10
				bits |= uint16(mant)
				fmt.Fprintf(w, "\t{bits: 0x%04X, want: %v},\n", bits, x)
			}
		}
	}
	fmt.Fprintln(w, "}")
}

func printDenormalized(w io.Writer) {
	const pre = `
var goldenDenormalized = []struct {
	bits uint16
	want float64
}{
	// Denormalized values.`
	fmt.Fprintln(w, pre[1:])
	// denormalized
	// 0b00000
	//
	//    (-1)^signbit * 2^(-14) * 0.mant_2
	const lead = 0
	for signbit := 0; signbit <= 1; signbit++ {
		// 0b1111111111
		const exp = 0
		for mant := 0; mant <= 0x3FF; mant++ {
			s := fmt.Sprintf("%s0b%d.%010bp0", "+", lead, mant)
			m, _, err := big.ParseFloat(s, 0, 53, big.ToNearestEven)
			if err != nil {
				panic(err)
			}
			mantissa, acc := m.Float64()
			if acc != big.Exact {
				panic("not exact")
			}
			x := math.Pow(-1, float64(signbit)) * math.Pow(2, exp-bias+1) * mantissa
			bits := uint16(signbit) << 15
			bits |= uint16(exp) << 10
			bits |= uint16(mant)
			if bits == 0x8000 {
				// -zero
				fmt.Fprintf(w, "\t{bits: 0x%04X, want: math.Copysign(0, -1)},\n", bits)
			} else {
				fmt.Fprintf(w, "\t{bits: 0x%04X, want: %v},\n", bits, x)
			}
		}
	}
	fmt.Fprintln(w, "}")
}
